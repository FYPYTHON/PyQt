2019/1/3，周四
H.323与SIP：
1）
H.323采用的是传统电话信令模式,包括一系列协议; 各个不同厂商的多媒体产品和应用可以进行互相操作,用户不必考虑兼容性问题;
SIP借鉴互联网协议,采用基于文本的协议.应用较为灵活,可扩展性强.两者各有侧重.
2）系统结构
H.323系统中,终端主要为媒体通信提供数据,功能比较简单,而对呼叫的控制、媒体传输控制等功能的实现则主要由网守来完成
集中式、层次式的控制模式.
SIP采用Client/Server结构的消息机制,对呼叫的控制是将控制信息封装到消息的头域中,通过消息的传递来实现.
分布式的控制模式.

2019/1/4，周五
分布式存储
1）对于一套分布式存储的方案，怎样评估它是好还是不好？
2）如何对分布式存储的不同实现进行分类？
3）分布式存储中的“数据可靠性”是如何计算的？
1）
运行或在线系统需要高性能。
离线或备份数据需要高容量，低价格。
所有的数据都必须是可靠的，绝对不能丢。
可靠性要求、可用性要求、时延要求、一致性要求、使用模式相关要求（包括请求大小、QPS/IOPS、吞吐）等
2）
对象存储: 也就是通常意义的键值存储，其接口就是简单的GET、PUT、DEL和其他扩展，如七牛、又拍、Swift、S3
对象存储（键值数据库）：接口简单，一个对象我们可以看成一个文件，只能全写全读，通常以大文件为主，要求足够的IO带宽。
块存储: 这种接口通常以QEMU Driver或者Kernel Module的方式存在，这种接口需要实现Linux的Block Device的接口或者QEMU提供的Block Driver接口，如Sheepdog，AWS的EBS，青云的云硬盘和阿里云的盘古系统，还有Ceph的RBD（RBD是Ceph面向块存储的接口）
块存储（硬盘）：它的IO特点与传统的硬盘是一致的，一个硬盘应该是能面向通用需求的，即能应付大文件读写，也能处理好小文件读写。但是硬盘的特点是容量大，热点明显。因此块存储主要可以应付热点问题。另外，块存储要求的延迟是最低的。
文件存储: 通常意义是支持POSIX接口（POSIX表示可移植操作系统接口），它跟传统的文件系统如Ext4是一个类型的，但区别在于分布式存储提供了并行化的能力，如Ceph的CephFS(CephFS是Ceph面向文件存储的接口)，但是有时候又会把GFS，HDFS这种非POSIX接口的类文件存储接口归入此类。
文件存储（文件系统）：支持文件存储的接口的系统设计跟传统本地文件系统如Ext4这种的特点和难点是一致的，它比块存储具有更丰富的接口，需要考虑目录、文件属性等支持，实现一个支持并行化的文件存储应该是最困难的。但像HDFS、GFS这种自己定义标准的系统，可以通过根据实现来定义接口，会容易一点。

业务逻辑分，那么可以分为：键值存储（Key-Value Storage）、文件系统（File System）、数据库（Database，不是很严谨，只是作为所有支持多键值的存储的统称）、消息队列（MQ）等等
存储即数据结构

	window文件挂载到Linux服务器：
cat /etc/fstab
mount -a
mount -t cifs -o username=wangguoqiang,vers=2.1 //172.16.83.87/kdfs /mnt/Wgq/kdfs

	Linux文件查看
0）cat xx.txt
1）diff   xx.txt xx.txt
2）more / less
将文件从第一行开始，根据输出窗口的大小，适当的输出文件内容
more的语法：more 文件名
Enter 向下n行，需要定义，默认为1行； 
Ctrl f 向下滚动一屏； 
空格键 向下滚动一屏； 
Ctrl b 返回上一屏； 
= 输出当前行的行号； 
:f 输出文件名和当前行的行号； 
v 调用vi编辑器； 
! 命令 调用Shell，并执行命令； 
q 退出more
3）head / tail

2019/1/5
1）无法运行“rc.exe”
https://www.cnblogs.com/chuijingjing/p/9159209.html
2）Python argparse用法总结
2a）
parse.add_argument('pkg',help='help')
//这是最基础的参数格式，如果是这样的格式，说明pkg是一个必须的参数，如果不加入这样的参数，则会报错
import argparse    //导入命令行解析的库文件
parse = argparse.ArgumentParser(description="test!!")  //为了别人执行代码的时候用--help看出来怎么使用这些代码
2b）
parse.add_argument('keyoukewu',help='keyoukewu'，nargs='?')  
//如果不加上最后一个参数nargs则执行代码的时候必须加上这个参数															
//如果有nargs说明这个参数可带可不带
2c）
parse.add_argument('-a','--abc',help='a sourcedir',nargs='?')
print(args.abc)
print(args.a) //是错误的
//运行时使用python demo.py -a abc
//或者使用python demo.py --abc abc(使用的是两个短横)
//参数的前面可以添加‘-’，也可以添加‘--’。说明添加的参数可以用简写也可以用全称来标明。但是解析的时候必须用全称。
2d）
parse.add_argument('-a','--abc',help='a sourcedir',action='store_true')
//这里的参数action的作用标明如果不写参数的话默认的print(args.a)的值是false，但是如果加上参数的话默认的print(args.a)的值
//为true，其中运行的参数的值不需要加上。
//如果很多的参数都加上了这些参数

parser.add_option("-v", action="store_true", dest="verbose")  
parser.add_option("-q", action="store_false", dest="verbose")  
这样的话，当解析到 ‘-v’，options.verbose 将被赋予 True 值，反之，解析到 ‘-q’，会被赋予 False 值。

parse.add_argument('-a','--abc',help='a sourcedir',action='store_true'，default=3)
//这时如果加上default的关键字，如果加上参数的话为则参数的值为1，但如果不加则采用默认的3，不再是0
//但是这时由于采用了action='store_true'的关键字，所以不再加上得关键字不能再跟着int的数字
//例如：python demo.py -a (is not ture.)
parse.add_argument('-a','--abc',help='a sourcedir',default=3)

2e）
parse.add_argument('-a','--abc',help='a sourcedir',nargs='?')
//这时参数的全名为abc，但是如果出现dest关键字，则全程为dest关键字定义的字段
parse.add_argument('-a','--abc'，dest='mn',help='a sourcedir',nargs='?')
//这时无论全名是mn，不再是abc
